import{o as a,c as s,b as e}from"./app.c212677f.js";const n='{"title":"Shell命令","description":"","frontmatter":{"sidebarDepth":3},"headers":[{"level":2,"title":"文件相关命令","slug":"文件相关命令"},{"level":3,"title":"find","slug":"find"},{"level":3,"title":"ack","slug":"ack"},{"level":3,"title":"grep","slug":"grep"},{"level":3,"title":"awk","slug":"awk"},{"level":3,"title":"tar","slug":"tar"},{"level":3,"title":"scp","slug":"scp"},{"level":3,"title":"rsync","slug":"rsync"},{"level":2,"title":"进程相关命令","slug":"进程相关命令"},{"level":2,"title":"管道","slug":"管道"},{"level":2,"title":"tree","slug":"tree"},{"level":2,"title":"time","slug":"time"},{"level":2,"title":"ssh","slug":"ssh"}],"relativePath":"front-end/command.md","lastUpdated":1674009752349}',t={},p=e('<h1 id="shell命令"><a class="header-anchor" href="#shell命令" aria-hidden="true">#</a> Shell命令</h1><p>熟练使用*nix系统的第一步便是熟练它的常用命令，大部分服务器的使用的Linux环境是没有GUI的，我们只能够通过命令来操控系统。对于前端开发来说，我们无需掌握大部分的高难度命令，只需掌握工作开发中常用的命令即可。如果不知道某个命令怎么用，最开始的时候是可以通过网络搜索来解决，稍微熟悉之后，就可以通过<code>man xxx</code>来查阅命令的手册来学习命令的各种参数。</p><h2 id="文件相关命令"><a class="header-anchor" href="#文件相关命令" aria-hidden="true">#</a> 文件相关命令</h2><p>熟练使用*nix系统下的复制 移动命令可以帮助我们写一些小的自动化shell脚本。例如在前端构建完毕后，将构建产物移动到指定目录或者重命名</p><div class="language-bash"><pre><code>$ <span class="token function">cp</span> ./a.txt <span class="token punctuation">..</span>/b.txt <span class="token comment"># 将当前目录下的a.txt文件复制到上级目录并更名</span>\n$ <span class="token function">mv</span> ./a.txt <span class="token punctuation">..</span>/b.txt <span class="token comment"># 将当前目录下的a.txt文件移动到上级目录并更名</span>\n$ <span class="token function">mv</span> ./a.txt ./b.txt <span class="token comment"># 重命名当前目录下的a.txt文件</span>\n</code></pre></div><h3 id="find"><a class="header-anchor" href="#find" aria-hidden="true">#</a> find</h3><p>使用 <code>find</code> 命令可以帮助我们查找符合要求的文件</p><div class="language-bash"><pre><code>$ <span class="token function">find</span> ./ -iname <span class="token string">&quot;*.js&quot;</span> <span class="token comment"># 查找当前目录下的所有js文件, 忽略大小写</span>\n$ <span class="token function">find</span> ./ -size +25k  <span class="token comment"># 查找当前目录下文件大小大于25kb的文件</span>\n</code></pre></div><h3 id="ack"><a class="header-anchor" href="#ack" aria-hidden="true">#</a> ack</h3><p>find的功能是比较弱的，对全文检索有心无力，ack是更好的搜索代码神器</p><p>安装</p><div class="language-bash"><pre><code>$ brew <span class="token function">install</span> ack \n</code></pre></div><p>然后，通过ack加关键字搜索即可。</p><div class="language-bash"><pre><code>$ ack targetCode\n$ ack -i <span class="token string">&quot;ICE BUILD&quot;</span> ./node_modules\n</code></pre></div><h3 id="grep"><a class="header-anchor" href="#grep" aria-hidden="true">#</a> grep</h3><p>使用 <code>grep</code> 命令可以帮助我们筛选符合要求的内容</p><div class="language-bash"><pre><code>$ <span class="token function">grep</span> <span class="token string">&quot;browserRouter&quot;</span> -i ./src/entry.tsx <span class="token comment"># 在当前src目录下的entry.tsx文件中查找browserRouter关键字忽略大小写</span>\n</code></pre></div><h3 id="awk"><a class="header-anchor" href="#awk" aria-hidden="true">#</a> awk</h3><p>通过awk命令我们可以筛选出符合要求的行或者列数据</p><p>以:为分隔符，将password分为多列，并且提取出第一列的内容</p><div class="language-bash"><pre><code>$ <span class="token function">cat</span> /etc/passwd <span class="token operator">|</span><span class="token function">awk</span> -F <span class="token string">&#39;:&#39;</span> <span class="token string">&#39;{print <span class="token variable">$1</span>}&#39;</span>\n</code></pre></div><h3 id="tar"><a class="header-anchor" href="#tar" aria-hidden="true">#</a> tar</h3><p>通过tar命令可以将文件打包并压缩，也可以解包和解压缩，配合别的命令可以写成简单的发布脚本。比如下面的命令就是一个打包压缩和解压缩的例子，将当前文件夹下的所有文件打包并gzip压缩，然后再来一遍解压缩</p><div class="language-bash"><pre><code><span class="token function">tar</span> -zcvf build.zip ./*\n<span class="token function">mkdir</span> <span class="token builtin class-name">test</span>\n<span class="token function">tar</span> -xvf build.zip -C ./test\n</code></pre></div><h3 id="scp"><a class="header-anchor" href="#scp" aria-hidden="true">#</a> scp</h3><p>打包好的文件可以通过scp来跨机器拷贝到集成调试服务器上面，比如我们本地打包好的文件是build.zip，需要拷贝到服务器上面/usr/share/nginx/html/，服务器ip是10.20.30.40，用户名是fe-deploy，就可以通过如下命令完成：</p><div class="language-bash"><pre><code><span class="token function">scp</span> ./build.zip fe-deploy@10.20.30.40:/usr/share/nginx/html/build.zip\n</code></pre></div><h3 id="rsync"><a class="header-anchor" href="#rsync" aria-hidden="true">#</a> rsync</h3><p>如果只是把打包好的文件推送到服务器上面，rsync会比上面先压缩再scp，再解压要简单很多。rsync就是用来同步两个目录，可以跨越网络。比如还是上面发布的例子，我们可以直接用下面的命令。<code>-r</code>是递归。<code>-v</code>是回显，都同步了哪些文件。<code>-z</code>是压缩。<code>--delete</code>是在目的目录删掉我们原目录不存在的文件。</p><div class="language-bash"><pre><code><span class="token function">rsync</span> -rvz ./ fe-deploy@10.20.30.40:/usr/share/nginx/html --delete\n</code></pre></div><h2 id="进程相关命令"><a class="header-anchor" href="#进程相关命令" aria-hidden="true">#</a> 进程相关命令</h2><div class="language-bash"><pre><code>$ <span class="token function">lsof</span> -i:8000 <span class="token comment"># 查看端口占用情况</span>\n$ <span class="token function">ps</span> <span class="token comment"># 查看当前正在运行的进程，ps命令选项众多这里不一一介绍</span>\n$ <span class="token function">kill</span> -9 pid <span class="token comment"># 根据进程pid来将进程强制退出</span>\n</code></pre></div><h2 id="管道"><a class="header-anchor" href="#管道" aria-hidden="true">#</a> 管道</h2><p>管道可以将上一个命令的stdout输出，作为下一个命令的stdin输入。通过管道符我们可以实现一些稍微复杂的自动化的脚本功能</p><p>比如，查找当前正在运行的Node进程并提取出pid传给kill命令来退出进程。</p><div class="language-bash"><pre><code>$ <span class="token function">ps</span> <span class="token operator">|</span> <span class="token function">grep</span> -i <span class="token string">&quot;node&quot;</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">&#39;{print <span class="token variable">$2</span>}&#39;</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">kill</span> -9 \n</code></pre></div><h2 id="tree"><a class="header-anchor" href="#tree" aria-hidden="true">#</a> tree</h2><p>大部分框架的文档都是使用tree命令来列出目录结构示例,更多功能查看<a href="https://wangchujiang.com/linux-command/c/tree.html" target="_blank" rel="noopener noreferrer">文档</a></p><div class="language-bash"><pre><code>$ tree -L <span class="token number">2</span> -I <span class="token string">&#39;node_modules&#39;</span> <span class="token comment"># 目录结构层级为2，忽略node_modules</span>\n├── app.js\n├── dist\n├── f.yml\n├── package.json\n└── src\n    ├── detail\n    ├── index\n    └── layout\n    \n</code></pre></div><h2 id="time"><a class="header-anchor" href="#time" aria-hidden="true">#</a> time</h2><p>time命令用于统计给定命令所花费的总时间。更多信息查看<a href="https://man.linuxde.net/time" target="_blank" rel="noopener noreferrer">文档</a></p><div class="language-bash"><pre><code>$ <span class="token function">time</span> <span class="token function">ls</span>\n</code></pre></div><h2 id="ssh"><a class="header-anchor" href="#ssh" aria-hidden="true">#</a> ssh</h2><p>有时候我们也需要登录到服务器上面，就可以通过<code>ssh</code>来登录。也可以通过配置把本地的公钥加到服务器上面，来省略输入密码的过程，详细的步骤可以搜索下，这里就不详细说了。</p><div class="language-bash"><pre><code>$ <span class="token function">ssh</span> fe-deploy@10.20.30.40\n</code></pre></div>',45);t.render=function(e,n,t,c,r,o){return a(),s("div",null,[p])};export default t;export{n as __pageData};
